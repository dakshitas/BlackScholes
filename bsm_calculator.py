# -*- coding: utf-8 -*-
"""BSM Calculator.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VoHik9Bk5Ku7KcDudnkVMFR8TiVqLlT6
"""

import numpy as np
import pandas as pd
import ipywidgets as widgets
from IPython.display import display, HTML
from alpha_vantage.timeseries import TimeSeries
from scipy.stats import norm
from datetime import datetime, date
import time

# Set up the Alpha Vantage API Key (Replace with your own API key if needed)
ALPHA_VANTAGE_API_KEY = "P2TQ5YPY8ZUDAMT7"
ts = TimeSeries(key=ALPHA_VANTAGE_API_KEY, output_format="pandas")

# Define global variables
TODAY = datetime(2025, 2, 20)  # Fixed date for calculations
risk_free_rate = 0.0495  # 10-Year Treasury Yield (4.95%)

# Function to compute historical volatility using 1-year stock data
def get_volatility(ticker):
    try:
        # Fetch daily stock prices from Alpha Vantage
        data, meta_data = ts.get_daily(symbol=ticker, outputsize="full")
        data = data.sort_index()  # Ensure chronological order

        # Keep only the last 252 trading days (1 year)
        data = data.iloc[-252:]

        # Compute daily returns
        returns = data["4. close"].pct_change().dropna()

        # Calculate annualized volatility using standard deviation and sqrt(252)
        return returns.std() * np.sqrt(252)
    except Exception as e:
        return None  # Return None if data retrieval fails

# Function to fetch the latest stock price from Alpha Vantage
def get_stock_price(ticker):
    try:
        # Fetch latest stock price
        data, meta_data = ts.get_quote_endpoint(symbol=ticker)

        # Ensure proper extraction of stock price using .iloc[0]
        return float(data["05. price"].iloc[0])
    except Exception as e:
        return None  # Return None if price retrieval fails

# Function to calculate Black-Scholes option price
def black_scholes_model(S, K, T, r, sigma, option_type):
    # Compute d1 and d2 for Black-Scholes formula
    d1 = (np.log(S / K) + (r + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))
    d2 = d1 - sigma * np.sqrt(T)

    # Compute option price based on type (Call or Put)
    if option_type == "call":
        price = S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)
    elif option_type == "put":
        price = K * np.exp(-r * T) * norm.cdf(-d2) - S * norm.cdf(-d1)
    else:
        raise ValueError("option_type must be 'call' or 'put'")

    return np.round(price, 3)  # Round result to 3 decimal places

# Create interactive UI elements using ipywidgets
ticker_select = widgets.Combobox(
    options=["AAPL", "MSFT", "JNJ", "GOOGL", "TSLA"],  # Predefined tickers
    description="Ticker:",
    placeholder="Enter ticker"
)

maturity_picker = widgets.DatePicker(
    description="Maturity:"  # Date picker for expiration date
)

strike_input = widgets.FloatText(
    description="Strike Price:",
    value=250  # Default strike price
)

option_type_radio = widgets.RadioButtons(
    options=["call", "put"],  # Choose between Call or Put
    description="Option Type:"
)

calculate_btn = widgets.Button(
    description="Calculate",  # Button to trigger calculation
    button_style="primary"
)

# Function to handle calculation when button is clicked
def on_calculate_click(b):
    try:
        # Retrieve selected ticker
        ticker = ticker_select.value
        if not ticker:
            display(HTML("<div style='color: red;'>Please enter a valid ticker!</div>"))
            return

        # Get stock price and volatility
        sigma = get_volatility(ticker)
        S = get_stock_price(ticker)

        # Handle errors if API fails
        if sigma is None or S is None:
            display(HTML(f"<div style='color: red;'>Failed to retrieve data for {ticker}. Try again later.</div>"))
            return

        # Get strike price from user input
        K = strike_input.value
        maturity_date = maturity_picker.value

        # Validate maturity date selection
        if maturity_date is None:
            display(HTML("<div style='color: red;'>Please select a valid expiration date.</div>"))
            return

        # Convert date picker output (datetime.date) to datetime.datetime
        maturity_date = datetime.combine(maturity_date, datetime.min.time())

        # Ensure the maturity date is in the future
        if maturity_date <= TODAY:
            display(HTML("<div style='color: red;'>Maturity date must be in the future.</div>"))
            return

        # Calculate time to expiration in years
        T = (maturity_date - TODAY).days / 252

        # Get risk-free rate and option type
        r = risk_free_rate
        option_type = option_type_radio.value

        # Compute Black-Scholes option price
        option_price = black_scholes_model(S, K, T, r, sigma, option_type)

        # Display results in formatted HTML
        result_html = f"""
        <div style='color: green; font-weight: bold;'>
            Black-Scholes {option_type} option price for {ticker}: ${option_price}
        </div>
        """
        display(HTML(result_html))

    except Exception as e:
        # Display error messages in red
        display(HTML(f"<div style='color: red;'>Error: {e}</div>"))

# Link button click event to calculation function
calculate_btn.on_click(on_calculate_click)

# Display all widgets in Jupyter Notebook
display(ticker_select, maturity_picker, strike_input, option_type_radio, calculate_btn)